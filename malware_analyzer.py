import sys

from androguard.util import set_log
from loguru import logger
from androguard.misc import AnalyzeAPK

# some settings
scan_all = False
log_level = "WARNING"

has_privacy_stealing = "has_privacy_stealing"
has_sms_or_call = "has_sms_or_call"
has_remote_control = "has_remote_control"
has_bank_stealing = "has_bank_stealing"
has_stealthy_download = "has_stealthy_download"
has_ransom = "has_ransom"
has_privilege_escalation = "has_privilege_escalation"

F_ZNIU = "ZNIU"
F_ROOTSTV = "ROOTSTV"
F_Slocker = "Slocker"
F_XLoader = "XLoader"

T_Rooting = "Rooting"
T_Exploit = "Exploit"
T_Ransomware = "Ransomware"
T_TrojanBanker = "Trojan-banker"

# definition of families, types and their features
rules = {
            T_Rooting: {
                "family": F_ZNIU,
                "features": [
                    has_privacy_stealing,
                    has_sms_or_call,
                    has_remote_control,
                    has_privilege_escalation,
                ]
            },
            T_Exploit: {
                "family": F_ROOTSTV,
                "features": [
                    has_remote_control,
                    has_stealthy_download,
                    has_privilege_escalation,
                ]
            },
            T_Ransomware: {
                "family": F_Slocker,
                "features": [
                    has_ransom,
                ]
            },
            T_TrojanBanker: {
                "family": F_XLoader,
                "features": [
                    has_privacy_stealing,
                    has_sms_or_call,
                    has_remote_control,
                    has_bank_stealing,
                    has_stealthy_download,
                    has_privilege_escalation,
                ]
            },
        }


class MalwareDetector:
    def __init__(self, app_path: str):
        self.app_path = app_path
        self.code_strings = set()
        self.identified_features = {}
        self.family = "unknown"
        self.type = "unknown"
        self.reports = {}

        self.apk, self.dex, self.analysis = AnalyzeAPK(self.app_path)


    def run(self):
        self.identified_features = {
            has_privacy_stealing: self.has_privacy_stealing(),
            has_sms_or_call: self.has_sms_or_call(),
            has_remote_control: self.has_remote_control(),
            has_bank_stealing: self.has_bank_stealing(),
            has_stealthy_download: self.has_stealthy_download(),
            has_ransom: self.has_ransom(),
            has_privilege_escalation: self.has_privilege_escalation(),
        }

        self.family, self.type = self.match_family_and_types()

        # print the analysis report
        print()
        print(f"apk path: {self.app_path}")
        print(f"============= ApkAnalyzer Report =============")
        print(f"potential malware family: {self.family if self.family else 'unknown'}")
        print(f"potential malware type: {self.type if self.type else 'unknown'}")
        print()
        no = 1
        for feature_name, log_lines in self.reports.items():
            print("features identified:")
            print(f">> [{no}]. {feature_name}:")
            no += 1
            for _, line in enumerate(log_lines):
                print(f"{line}")
            print()

        return self.identified_features, self.family, self.type


    def match_family_and_types(self):
        found_family, found_typ = '', ''
        true_keys = [k for k, v in self.identified_features.items() if v]
        for _typ, rule in rules.items():
            if set(rule['features']).issubset(set(true_keys)):
                found_family = rule['family']
                found_typ = _typ
                break

        return found_family, found_typ


    def get_all_strings(self):
        if len(self.code_strings) == 0:
            self.code_strings = set()
            for dex in self.dex:
                for s in dex.get_strings():
                    self.code_strings.add(s)

        return self.code_strings


    def report(self, feature_name: str, log_line: str):
        if feature_name not in self.reports:
            self.reports[feature_name] = []

        self.reports[feature_name].append(log_line)
        return


    def has_privacy_stealing(self) -> bool:
        logger.debug(f"detecting feature: [privacy_stealing] for app: {self.app_path}")

        privacy_permissions = {
            "android.permission.READ_CONTACTS",
            "android.permission.READ_SMS",
            "android.permission.ACCESS_FINE_LOCATION",
            "android.permission.READ_PHONE_STATE",
        }
        sensitive_api_calls = [
            "getDeviceId",
            "getSubscriberId",
            "getSimSerialNumber",
            "getLastKnownLocation",
        ]

        matched_permissions = privacy_permissions & set(self.apk.get_permissions())
        if matched_permissions:
            self.report(has_privacy_stealing, f"found privacy permission used: {matched_permissions}")
            return True
        for method in self.analysis.get_methods():
            if any(api in method.name for api in sensitive_api_calls):
                self.report(has_privacy_stealing, f"found sensitive apis used: {method.name}")
                return True

        return False


    def has_sms_or_call(self) -> bool:
        logger.debug(f"detecting feature: [sms_or_call] for app: {self.app_path}")

        sms_permissions = {
            "android.permission.SEND_SMS",
            "android.permission.READ_SMS",
            "android.permission.RECEIVE_SMS",
            "android.permission.CALL_PHONE",
        }
        sms_api_calls = [
            "sendTextMessage",
        ]

        matched_permissions = sms_permissions & set(self.apk.get_permissions())
        if matched_permissions:
            self.report(has_sms_or_call, f"found sms_call_permissions used: {matched_permissions}")
            return True
        for method in self.analysis.get_methods():
            if any(api in method.name for api in sms_api_calls):
                self.report(has_sms_or_call, f"found sms_call apis used: {method.name}")
                return True

        return False


    def has_remote_control(self) -> bool:
        logger.debug(f"detecting feature: [remote_control] for app: {self.app_path}")

        network_classes = [
            "java/net/Socket",
            "java/net/HttpURLConnection",
            "org/apache/http",
        ]

        for method in self.analysis.get_methods():
            for c in network_classes:
                if c in method.class_name:
                    self.report(has_remote_control, f"found network lib used: {c}")
                    return True

        return False


    def has_bank_stealing(self) -> bool:
        logger.debug(f"detecting feature: [bank_stealing] for app: {self.app_path}")

        for method in self.analysis.get_methods():
            if "getInstalledPackages" in method.name:
                self.report(has_bank_stealing, f"found getInstalledPackages used")
                return True
            if "WebView" in method.class_name and "loadUrl" in method.name:
                self.report(has_bank_stealing, f"found WebView used, potential phishing risks")
                return True

        return False


    def has_stealthy_download(self) -> bool:
        logger.debug(f"detecting feature: [stealthy_download] for app: {self.app_path}")

        stealth_classes = [
            "android/app/DownloadManager",
        ]

        for method in self.analysis.get_methods():
            for c in stealth_classes:
                if c in method.class_name:
                    self.report(has_stealthy_download, f"found DownloadManager used")
                    return True

        src = self.get_all_strings()
        if ("getInputStream" in src or "openConnection" in src) and ("FileOutputStream" in src or "write(" in src):
            self.report(has_stealthy_download, f"found http download and write behaviors")
            return True

        return False


    def has_ransom(self) -> bool:
        logger.debug(f"detecting feature: [ransom] for app: {self.app_path}")

        crypto_keywords = [
            "javax/crypto/Cipher",
            "java/security/KeyGenerator",
        ]
        lock_behavior = [
            "moveTaskToBack",
            "onBackPressed",
        ]

        for method in self.analysis.get_methods():
            if any(c in method.class_name for c in crypto_keywords):
                self.report(has_ransom, f"found crypto lib used")
                return True
            if any(b in method.name for b in lock_behavior):
                self.report(has_ransom, f"found moveTaskToBack operations")
                return True

        return False


    def has_privilege_escalation(self) -> bool:
        logger.debug(f"detecting feature: [privilege_escalation] for app: {self.app_path}")

        strs = self.get_all_strings()
        has_su = any(s == "su" or s.startswith("su ") for s in strs)
        has_exec = any("Runtime.exec" in s for s in strs)
        if has_su and has_exec:
            self.report(has_privilege_escalation, f"found 'su' used")
            return True
        for cmd in ["chmod", "mount", "ptrace"]:
            if any(cmd in s for s in strs):
                self.report(has_privilege_escalation, f"found privileged cmds like chmod, mount, ptrace")
                return True
        if any("loadLibrary" in s for s in strs):
            self.report(has_privilege_escalation, f"found dynamically lib loading")
            return True

        return False


def print_help():
    print()
    print("Usage: python malware_analyzer.py <path_to_apk_file> [-l WARNING] [-h]")
    print("    -l: (optional) specify logging level, default to WARNING")
    print("        can be one of (TRACE, DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL)")
    print("    -h: show this help info")
    print()


def main():
    global scan_all, log_level

    if len(sys.argv) < 2 or '-h' in sys.argv:
        print_help()
        return

    apk_path = sys.argv[1]
    scan_all = '-a' in sys.argv

    # (optional) specify logging level, default to WARNING
    # can be one of (TRACE, DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL)
    if '-l' in sys.argv:
        try:
            log_level = sys.argv[sys.argv.index('-l') + 1]
        except IndexError:
            print("Error: -l provided but no log level specified")
            return

    # logging level
    set_log(log_level)

    detector = MalwareDetector(apk_path)
    detector.run()
    print()

if __name__ == "__main__":
    main()